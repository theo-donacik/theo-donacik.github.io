[
  {
    "id": "minecraft",
    "name": "Minecraft Server Control",
    "date": "June 2023",
    "shortDescription": "Self-hosted Minecraft server and web control console",
    "fullDescription": "My friends and I like to play Minecraft together, but that requires an external server. We had been paying for a service to host one for us, but it was expensive, hard to switch versions, and had frequent performance problems. So, equipped with my friend's old PC parts and a Raspberry Pi, I worked to create a self-hosted solution that anyone in our group would be able to use. The server consists of two parts: A high-power former gaming PC, now running Debian 12, which hosts the game server itself, and a Raspberry Pi single board computer which hosts the web app used to control it. Rather than keeping the much more inefficient PC on at all times to serve the web app component, the Pi can stay always on, connected to the PC via USB and uses the RPI's 'gadget mode' to wake the device from a shut down state. Once on, the PC hosts PHP API endpoints that the Pi interacts with to turn different game versions on or off, get stats and console logs from the game server, or shut the PC back down. Hosted on the internet with a free hostname from afraid.org, any of my friends can turn the server on, connect to it via the same hostname on a different port, and turn it off when they're done. Being able to wake the server remotely was the biggest challenge of this project. I originally attempted a Wake on Lan solution, but quickly found that due to a bug in this specific motherboard's firmware, WOL had been disabled in the linux kernel. I moved on to trying to get the RPI to act as a USB keyboard in gadget mode to turn the device on, but this too had been removed from the Pi kernel's DWC2 driver. I eventually found a kernel patch online which reenabled this feature, so after cross compiling the RPI kernel for ARM64 on my main machine, I was able to remotely power on and off the server.",
    "tileImage": "/img/projectImg/MineTile.png",
    "carouselImages": ["/img/projectImg/MineCar1.png", "/img/projectImg/MineCar2.png"]
  },
  {
    "id": "2048",
    "name": "2048",
    "date": "March 2023",
    "shortDescription": "A game of 2048 made in TypeScript",
    "fullDescription": "This simple game of 2048 replicates the original game's mechanics and includes multiple themes on top of the base game. This game served as a project to help get me familiar with TypeScript, implementing elements of object oriented design to represent the game board and more functional use effect hooks which are common in React-based web projects. The game uses browser local storage to keep a copy of the game state which is restored when the game loads to save a user's game from their last session. Featuring my partner's cat!",
    "demoLink": "/projects/2048game",
    "tileImage": "/img/projectImg/2048Tile.png",
    "carouselImages": ["/img/projectImg/2048Car1.png", "/img/projectImg/2048Car2.png", "/img/projectImg/2048Car3.png"]
  },
  {
    "id": "shell",
    "name": "Shell in C",
    "date": "February 2023",
    "shortDescription": "A shell program which tokenizes and executes user input",
    "fullDescription": "This is a shell program written in C for my computer systems class. It reads and tokenizes user input and runs it on the system using exec. It supports scripting, sequencing, input and output redirection, and recalling previous commands. Dealing with memory management on this project and the course in general was my biggest challenge, but working on this project has given me a much better idea of how to think about C memory management. The shell is an essential part of a computer system, and one that I interact with regularly, so it was very interesting to learn how these programs interpret text input, and also helped me understand the nuances of input redirection that were previously unknown to me. I find low level programs such as this one to be quite elegant. They require extreme delicacy and deliberate thought, at the end feeling like I've put together a complex puzzle, even if it produces an already familiar image.",
    "tileImage": "/img/projectImg/ShellTile.png",
    "carouselImages": ["/img/projectImg/ShellCar1.png", "/img/projectImg/ShellCar2.png", "/img/projectImg/ShellCar3.png", "/img/projectImg/ShellCar4.png"]
  },
  {
    "id": "raft",
    "name": "RAFT",
    "date": "December 2022",
    "demoLink": "https://github.com/theo-donacik/RAFT",
    "shortDescription": "An implementation of the RAFT consensus protocol",
    "fullDescription": "This was a project for CS3700 Networks and Distributed Systems, done with my partner Jaron Cui. In this project, our task was to create a basic implementation of the RAFT consensus protocol for distributed data storage. We were given a simulator program which would create data storage nodes running our RAFT software which could communicate with each other. They would then receive data write and read requests and be spontaneously killed, requiring data redundancy and consistency. We read the original RAFT paper (https://raft.github.io/raft.pdf) detailing the mechanism by which distributed nodes would vote to elect a leader which receives all incoming write requests and replicates that data to its followers, ensuring no new data is committed to the ledger unless a consensus has been reached. Our solution had to be resilient to leader and follower crashes and ensure data consistency among the nodes. In the end I feel we created a very elegant implementation which required a deep understanding of the RAFT mechanism, distributed data storage, and democracy.",
    "tileImage": "/img/projectImg/RaftTile.png",
    "carouselImages": ["/img/projectImg/RaftCar1.png", "/img/projectImg/RaftCar2.png", "/img/projectImg/RaftCar3.png"]
  },
  {
    "id": "trophy",
    "name": "Wingspan Trophy App",
    "date": "August 2021",
    "shortDescription": "A scorekeeping mobile app",
    "fullDescription": "I love board games, and out of all of them, Wingspan is my favorite. My whole family is quite hooked, to the point of purchasing a trophy we pass around to the winner of our frequent games. With my sister and I away for college I wanted a way to keep track of this trophy won during our digital matches, so I created a mobile app to keep a score record. The app has 2 major components, the frontend created in React Native, and the backend hosted on my personal Raspberry Pi web server. The frontend app displays the current trophy holder and can be used to insert scores and recall past scores. I packaged it as both an Android and IOS app and distributed it to members of my family. The backend was hosted on a Raspberry Pi acting as a LAMP (Linux, Apache, MySQL, PHP) server, port forwarded to the internet with a free hostname and served PHP API endpoints for inserting and retrieving records into a MySQL database. The backend hasn't survived several reimages of the Pi, but its spirit lives on in future projects where I use similar PHP endpoints for interacting with other applications on the server.",
    "tileImage": "/img/projectImg/TrophyTile.png",
    "carouselImages": ["/img/projectImg/TrophyCar1.jpg", "/img/projectImg/TrophyCar2.jpg", "/img/projectImg/TrophyCar3.jpg"]
  }
]